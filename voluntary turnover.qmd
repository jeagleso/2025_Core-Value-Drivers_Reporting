---
title: "Voluntary Turnover"
format: html
editor: visual
---

```{r}
#| label: setup
#| warning: false
library(tidyverse)

# specify period: first date of current year and last day of previous month
start_date <- as.Date(floor_date(Sys.Date(), "year"))
end_date <- as.Date("2025-02-28")
# end_date <- as.Date(floor_date(Sys.Date(), "month") - days(1))

# get all months included in period
months_included <- seq(start_date, end_date, by = "month")

# get the last date of each month
last_day_of_month <- ceiling_date(months_included, "month") - days(1)

# data frame with all months
monthly_data <- tibble(last_day_of_month = as.Date(last_day_of_month))

# filters to be applied
# filter() does not include NA by default
apply_filters <- function(df) {
  df |>  
    filter(worker_type == "Employee") |> 
    filter((job_family_group != "Human Resources") |> replace_na(TRUE)) |> 
    filter(segment_function != "Industrial Systems")
}

# set the grouping variables of interest
# if changing grouping variables, also add output_sheet_name
grouping_vars <- list(NULL, 
                      "segment_function", 
                      c("segment_function", "division_function"), 
                      c("segment_function", "division_function", "business_unit_sub_function"),
                      c("segment_function", "division_function", "location"),
                      c("segment_function", "career_level_bucket"),
                      "career_level_bucket")

# set name for output sheet name for each grouping variable
output_sheet_names <- c("Enterprise",
                        "Segment",
                        "Segment by Division",
                        "Division by Subfunction",
                        "Division by Location",
                        "Segment by Level",
                        "Enterprise by Level")
```

```{r}
#| label: get_data

# get active and terminated, add career_level bucket
active_and_terminated <- readxl::read_xlsx("inputs/People Analytics - AT.xlsx", skip = 4) |> 
  janitor::clean_names() |> 
  mutate(career_level_bucket = factor(case_when(
    career_level %in% c("E2", "E3", "E4", "E5") ~ "VP",
    career_level %in% c("M5", "E1") ~ "Director",
    career_level %in% c("M2", "M3", "M4") ~ "Manager",
    career_level == "M1" ~ "Supervisor",
    career_level %in% c("P1", "P2", "P3", "P4", "P5", "P6") ~ "Professional",
    career_level %in% c("AT1", "AT2", "AT3", "AT4") ~ "Administrative_Technical",
    is.na(career_level) ~ "None",
    TRUE ~ "ERROR_unmapped_level"),
    levels = c("VP", "Director", "Manager", "Supervisor", "Professional", "Administrative_Technical", "None", "ERROR_unmapped_level"),
    ordered = TRUE))

pa_at <- active_and_terminated |> 
  apply_filters()
```

```{r}
#| label: calculate_turnover_at_file

calculate_voluntary_turnover_monthly <- function(grouping_var) {
  
  # allows join for NULL aka enterprise
  if (is.null(grouping_var)) {
    grouping_var <- "Enterprise"
    pa_at <- pa_at |> mutate(Enterprise = "Enterprise")
  }

  # for each date in last_day_of_month do this function
  monthly_results <- map_df(last_day_of_month, function(date) {
  
  # get monthly headcount inclusive
  headcount <- pa_at |> 
    filter(hire_date <= date & (is.na(termination_date) | termination_date >= date)) |> 
    group_by(across(all_of(grouping_var))) |> 
    summarize(headcount = n(), .groups = 'drop')
  
  # get monthly voluntary terminations
  voluntary_terminations <- pa_at |> 
    filter(termination_category == "Terminate Employee > Voluntary" &
          termination_date >= floor_date(date, "month") &
          termination_date <= date) |> 
    group_by(across(all_of(grouping_var))) |> 
    summarize(voluntary_terminations = n(), .groups = 'drop')

  # combine headcount and VTs, calculate voluntary turnover
  result <- left_join(headcount, voluntary_terminations, by = grouping_var) |> 
    mutate(
      date = month(date, label = TRUE),
      voluntary_terminations = coalesce(voluntary_terminations, 0), # returns 0 if none
      voluntary_turnover = voluntary_terminations / headcount
      )
  
  return(result)
})

 # calculate YTD turnover
  ytd_results <- monthly_results |> 
    group_by(across(all_of(grouping_var))) |> 
    summarize(
      voluntary_terminations = sum(voluntary_terminations),
      headcount = mean(headcount, na.rm = TRUE),
      voluntary_turnover = voluntary_terminations / headcount,
      .groups = 'drop'
    ) |> 
    mutate(
      date = "YTD",
      ytd_annualized = voluntary_turnover * (12 / length(last_day_of_month))
    )
  
  # combine monthly and YTD results
  final_results <- bind_rows(
    monthly_results |> mutate(date = as.character(date)),
    ytd_results
  )
  
  return(final_results)
}
```

```{r}
# get results for all grouping variable combinations
monthly_turnover_data <- map(grouping_vars, ~ calculate_voluntary_turnover_monthly(.x)) |> 
  set_names(output_sheet_names)
```

```{r}
# get a df with all active in each month
monthly_headcount <- map_df(last_day_of_month, function(date) {

headcount <- pa_at |> 
  filter(hire_date <= date & (is.na(termination_date) | termination_date >= date)) |> 
  mutate(date = month(date, label = TRUE))

return(headcount)
})

# separates one monthly df into one for each month
monthly_headcount_named <- monthly_headcount |> 
  nest_by(date) |> 
  mutate(data = set_names(list(data), date))

# adds a df for each monthly headcount
for (i in unique(monthly_headcount_named$date)) {
  monthly_turnover_data[[i]] <- monthly_headcount_named$data[[which(monthly_headcount_named$date == i)]]
}


# get vol terms sheet
voluntary_terminations <- pa_at |> 
  filter(termination_category == "Terminate Employee > Voluntary" &
        termination_date >= floor_date(start_date, "month") &
        termination_date <= end_date)
```

```{r}
# monthly turnover rate for enterprise
monthly_turnover_rate_at_file <- monthly_data |>
  rowwise() |> 
  mutate(
    previous_month = floor_date(last_day_of_month, unit = "month") - days(1),
    voluntary_terminations = sum(!is.na(pa_at$termination_date) & 
                        pa_at$termination_category == "Terminate Employee > Voluntary" &
                       pa_at$termination_date <= last_day_of_month & 
                       pa_at$termination_date > previous_month),
    headcount = sum(pa_at$hire_date <= last_day_of_month & 
                      (is.na(pa_at$termination_date) |
                         pa_at$termination_date >= last_day_of_month))) |> 
  ungroup() |> 
  mutate(voluntary_turnover = voluntary_terminations / headcount)
```

FAQ:

-   Associates are included in headcount if their termination day is on or after the last day of the month (e.g., an Associate will be included in January's headcount if their termination date is 1/31 or later).

```{r}
jan_hc <- readxl::read_xlsx("C:/Users/610171734/OneDrive - Regal Rexnord/Documents/2024/2024_Core Value Drivers_Reporting/inputs/2024_HC/RRX - Data Validation_1 JAN2024 2024-01-31.xlsx", sheet = "Raw Data", skip = 17) |> 
  janitor::clean_names()

tmp <- jan_hc |> 
  filter(segment_function_l1 != "Industrial Systems") |> 
  filter(worker_type == "Employee")

# Filter to include only employees in the effective date headcount
tmp_headcount <- active_and_terminated_employees %>%
  filter(hire_date <= "2024-01-31" & 
         (is.na(termination_date) | termination_date >= "2024-01-31"))

# Write the filtered data to a CSV file
write.csv(tmp_headcount, "tmp_jan_headcount.csv", row.names = FALSE)
```

# HIPO Jerry Morton

```{r}
a_t_aip <- active_and_terminated |> 
  filter(x9box_numeric %in% c("3.3", "3.2", "2.3")) |> 
  filter(x9box_potential != "Too New To Rate" & 
           x9box_potential != "New to Company") |> 
  filter(management_chain_level_2 == "Jerry Morton")

# assumes running YTD through last full month of current year
months_included <- seq(floor_date(Sys.Date(), "year"), 
          floor_date(Sys.Date(), "month") - days(1), by = "month")

last_day_of_month <- ceiling_date(months_included, "month") - days(1)

# data frame with all months
monthly_data <- tibble(last_day_of_month = last_day_of_month)

monthly_turnover_rate_at_file <- monthly_data |>
  rowwise() |> 
  mutate(
    previous_month = floor_date(last_day_of_month, unit = "month") - days(1),
    terminations = sum(!is.na(a_t_aip$termination_date) & 
                       a_t_aip$termination_date <= last_day_of_month & 
                       a_t_aip$termination_date > previous_month),
    headcount = sum(a_t_aip$hire_date <= last_day_of_month & 
                      (is.na(a_t_aip$termination_date) |
                         a_t_aip$termination_date >= last_day_of_month))) |> 
  ungroup() |> 
  mutate(turnover_rate = terminations / headcount)
```

### Future Ideas

- Create a function to make an active file and term file for each month from the AT file

- Possible to embed in body of email to flag for HRBP VPs?
